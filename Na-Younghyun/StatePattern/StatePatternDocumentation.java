package StatePattern;

/**
 * <h2>State 패턴이란</h2>
 * State 패턴은 객체의 행동을 상태 클래스로 위임함으로써 객체의 상태 전이를 효과적으로 관리할 수 있도록 하는 패턴입니다.<br>
 * 이 패턴을 사용하면 상태를 한 곳에서 관리하여 변경을 최소화할 수 있다는 장점이 있습니다.<br>
 * <br>
 * <img src="../img/state.png" alt="State Pattern UML Diagram">
 * <br>
 *
 * <ul>
 *    <li>Context: 여러 가지 상태를 가지고 있으며 각 상태에 따라 동작이 수행되도록 구현하는 클래스입니다.</li>
 *    <li>State: 모든 상태가 구현해야 할 공통 인터페이스입니다.</li>
 *    <li>ConcreteState: State를 구현한 클래스로, 각 상태에 따라 다른 요청을 처리하는 방법을 구현합니다.</li>
 * </ul>
 *
 * <br><br>
 *
 * <h2>State 패턴 활용 예시</h2>
 * <br>
 * <h2>Example02.뽑기 기계 시뮬레이션</h2>
 * <img src="../img/state01.png" alt="ticketFactory">
 * <br>
 * <ul>
 *    <li>GumballMachine: 현재 상태를 추적하고, 각 상태에서 필요한 동작을 호출하는 State 패턴의 Context 역할을 수행합니다.</li>
 *    <li>State: 상태 객체들이 반드시 구현해야 하는 메서드를 선언하여 다양한 상태를 표현하고 관리하는 데 필요한 구조를 제공합니다. </li>
 *    <li>HasQuarterState: State 인터페이스를 구현한 클래스로, 동전이 있는 상태를 나타냅니다.</li>
 *    <li>NoQuarterState: State 인터페이스를 구현한 클래스로, 동전이 없는 상태를 나타냅니다.</li>
 *    <li>SoldOutState: State 인터페이스를 구현한 상태 클래스로, 알맹이가 매진된 상태를 나타냅니다.</li>
 * </ul>
 * <br>
 * <h3>시나리오 1: 새로운 기능 추가 (ex. 5번 뽑으면 알맹이 하나 더 주는 기능)</h3>
 *
 * <b>Before: State 패턴을 사용하지 않은 코드</b>
 * <p>
 *   새로운 상태를 추가하려면 상태를 나타내는 정수 상수 및 분기 처리 로직을 변경해야 합니다.
 *   이로 인해 GumballMachine 클래스가 복잡해지고, 새로운 상태를 추가하거나 기존 상태를 변경하기 어려워집니다.
 * </p>
 * <br>
 * <b>After: State 패턴을 사용한 코드</b>
 * <p>
 *    새로운 기능을 추가하는 과정이 간단합니다.
 *    새로운 상태 클래스를 만들고 State 인터페이스를 구현하여 GumballMachine에 새로운 상태를 추가합니다.
 *    상태 전환과 관련된 모든 로직은 상태 클래스 내부에 캡슐화되므로 GumballMachine 클래스의 변경이 최소화됩니다.
 *    이렇게 하면 기존 코드에 영향을 미치지 않고 새로운 동작을 확장할 수 있습니다.
 * </p>
 * <br>
 * <h3>시나리오 2: 기존 기능 삭제</h3>
 *
 * <b>Before: State 패턴을 사용하지 않은 코드</b>
 * <p>
 *    해당 상태와 관련된 모든 분기 처리 로직을 제거해야 합니다.
 *    이는 코드를 불안정하게 만들고 오류가 발생할 가능성을 높입니다.
 * </p>
 * <br>
 * <b>After: State 패턴을 사용한 코드</b>
 * <p>
 *    해당 상태 클래스를 제거하면 됩니다. 이로 인해 코드가 깔끔하게 유지됩니다.
 * </p>
 *
 * <br><br>
 * <h3>State 패턴의 장점</h3>
 * <p>
 *    State 패턴을 사용한 코드에서의 장점은 다음과 같습니다:
 * </p>
 * <ul>
 *    <li>유연성과 확장성: 새로운 상태를 추가하거나 기존 상태를 변경하기 쉽습니다.</li>
 *    <li>코드의 가독성 및 유지보수성 향상: 각 상태가 자체적으로 동작을 정의하고 있으므로 코드가 명확하고 유지보수가 용이합니다.</li>
 *    <li>캡슐화: 각 상태 클래스는 자체적으로 상태와 관련된 동작을 캡슐화하고 있으므로 코드의 모듈화가 가능합니다.</li>
 * </ul>
 * <p>
 *    State 패턴을 사용하면 상태와 관련된 코드를 유연하게 관리할 수 있도록 하여 앞으로의 변경사항에 대비할 수 있습니다.
 * </p>
 *
 *
 */
public class StatePatternDocumentation{
}