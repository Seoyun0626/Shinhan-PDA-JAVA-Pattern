package FactoryPattern;

/**
 *
 * <h2>Factory 패턴이란</h2>
 * Factory 패턴은 클래스의 객체를 생성 시 객체의 종류의 변화로 인한 클라이언트 코드 수정의 번거로움으로 인해 등장한 패턴입니다.<br>
 * 패턴 사용 방법은 객체의 생성을 분리해서 캡슐화 시키기 위해 클래스의 인스턴스를 만드는 것을 서브클래스에서 결정하도록 하는 것입니다.<br>
 * 이 패턴을 사용하면 객체 생성의 책임을 분리하여 코드를 명확히 분리할 수 있고, 객체를 추가하거나 삭제할 시 기존 코드를 수정하지 않고 변경이 가능해 유지보수가 용이하다는 장점이 있습니다.<br>
 * <br>
 * <img src="../img/factory.png" alt="Factory Method Pattern UML Diagram">
 * <br>
 * Factory Method 패턴은 객체 생성을 서브 클래스에 위임하여 객체 생성과 관련된 코드를 추상화하는 데 사용됩니다.
 *
 * <ul>
 *    <li>Factory: 제품을 생성하고 등록하는 추상 클래스입니다.</li>
 *    <li>Product: 제품을 나타내는 추상 클래스입니다.</li>
 *    <li>ConcreteFactory: Factory 클래스의 구체적 하위 클래스로, 실제 제품을 생성하고 등록합니다.</li>
 *    <li>ConcreteProduct: Product 클래스의 구체적 하위 클래스로, 실제 제품을 나타냅니다.</li>
 *    <li>Main 클래스: Factory Method 패턴을 사용하여 실제 제품을 생성하고 사용하는 예제를 제공합니다.</li>
 * </ul>
 *
 * <br><br>
 *
 * <h2>Factory 패턴 활용 예시</h2>
 * <h2>Factory 패턴을 사용한 코드 vs. 사용하지 않은 코드</h2>
 * <br>
 * <h2>Example01.이벤트 별 티켓 생성하기</h2>
 * <img src="../img/ticket_factory.png" alt="ticketFactory">
 * <br>
 * <ul>
 *    <li>Factory: 제품을 생성하고 등록하는 추상 클래스입니다.</li>
 *    <li>Product: 제품을 나타내는 추상 클래스입니다.</li>
 *    <li>ConcreteFactory: Factory 클래스의 구체적 하위 클래스로, 실제 제품을 생성하고 등록합니다.</li>
 *    <li>ConcreteProduct: Product 클래스의 구체적 하위 클래스로, 실제 제품을 나타냅니다.</li>
 *    <li>Main 클래스: Factory Method 패턴을 사용하여 실제 제품을 생성하고 사용하는 예제를 제공합니다.</li>
 * </ul>
 * <br>
 * <h3>시나리오 1: 새로운 이벤트 추가</h3>
 *
 * <b>Before: Factory 패턴을 사용하지 않은 코드</b>
 * <p>
 *    Ticket 클래스를 직접 수정하여 새로운 이벤트에 대한 생성자를 추가해야 합니다.
 *    Main 클래스에서 새로운 Ticket 객체를 생성하고 사용하는 코드를 작성해야 합니다.
 *    이 작업을 기존 코드를 변경하고 이벤트가 추가될 때마다 수정해야 합니다.
 * </p>
 * <br>
 * <b>After: Factory 패턴을 사용한 코드</b>
 * <p>
 *    새로운 이벤트를 추가하는 과정이 간단합니다.
 *    Product를 상속하는 새로운 클래스를 작성하고 TicketFactory 클래스에 해당 이벤트를 생성하는 메서드를 추가합니다.
 *    Main 클래스에서는 기존 코드를 수정하지 않고 TicketFactory에 새로운 이벤트 클래스를 등록하여 사용합니다.
 * </p>
 * <br>
 * <h3>시나리오 2: 기존 이벤트 삭제</h3>
 *
 * <b>Before: Factory 패턴을 사용하지 않은 코드</b>
 * <p>
 *    Ticket 클래스에서 해당 이벤트에 대한 생성자와 관련 코드를 모두 제거해야 합니다.
 *    Main 클래스에서 기존 이벤트 객체를 생성하는 코드를 삭제해야 합니다.
 *    이 작업은 기존 코드의 많은 부분을 변경해야 하므로 코드의 변경 범위가 넓어집니다.
 * </p>
 * <br>
 * <b>After: Factory 패턴을 사용한 코드</b>
 * <p>
 *    해당 이벤트를 나타내는 클래스를 삭제하고, TicketFactory 클래스에서 해당 이벤트를 생성하는 메서드를 삭제합니다.
 *    Main 클래스는 수정하지 않아도 됩니다.
 * </p>
 *
 *<br><br>
 * <h2>Example02.케이크 가게에서 케이크 주문 및 서빙 시뮬레이션</h2>
 *
 * <img src="../img/cake_factory.png" alt="cakeFactory">
 * <br>
 * <ul>
 *    <li>CakeFactory: 케이크를 생성하는 클래스입니다.</li>
 *    <li>Cake: 케이크을 나타내는 추상 클래스입니다.</li>
 *    <li>CakeStore: 케이크를 주문하고 생성하는 클래스입니다.</li>
 *    <li>ChocolateCake: Cake 클래스 구체적 하위 클래스로, 실제 케이크를 나타냅니다.</li>
 *    <li>StrawberryCake: Cake 클래스 구체적 하위 클래스로, 실제 케이크를 나타냅니다.</li>
 *    <li>VanillaCake: Cake 클래스 구체적 하위 클래스로, 실제 케이크를 나타냅니다.</li>
 * </ul>
 * <br>
 * <h3>시나리오 1: 새로운 케이크 메뉴 추가</h3>
 *
 * <b>Before: Factory 패턴을 사용하지 않은 코드</b>
 * <p>
 *    Factory 패턴을 사용하지 않은 코드에서는 새로운 케이크를 추가하기 위해서는 CakeStore 클래스의 orderCake 메서드에 조건문을 추가해야 합니다.
 *    각 케이크를 생성하고 서빙하는 코드가 중복되어 있어서, 새로운 케이크를 추가할 때마다 이 부분을 수정해야 합니다.
 *    이는 코드의 유지보수를 어렵게 만들며, 새로운 케이크를 추가할 때 기존 코드를 변경해야 한다는 불편함을 초래합니다.
 * </p>
 * <br>
 * <b>After: Factory 패턴을 사용한 코드</b>
 * <p>
 *    Factory 패턴을 사용한 코드에서는 새로운 케이크를 추가하는 과정이 간단합니다.
 *    새로운 케이크 클래스를 작성하고, CakeFactory 클래스에 해당 케이크 클래스를 생성하는 메서드를 추가하면 됩니다.
 *    새로운 케이크를 주문하려면 기존 코드를 수정하지 않고도 CakeFactory에 새로운 케이크 클래스를 등록하여 사용할 수 있습니다.
 *    이렇게 하면 코드의 확장성이 뛰어나며 변경 사항이 최소화됩니다
 * </p>
 * <br>
 * <h3>시나리오 2: 기존 케이크 메뉴 삭제</h3>
 *
 * <b>Before: Factory 패턴을 사용하지 않은 코드</b>
 * <p>
 *    기존의 케이크를 삭제하는 경우, 해당 케이크에 대한 조건문을 제거해야 합니다.
 *    이 경우 코드의 수정이 필요하며, CakeStore 클래스 내부의 조건문을 모두 변경해야 합니다.
 *    이로 인해 코드의 변경 범위가 넓어져 유지보수가 어려워집니다.
 * </p>
 *<br>
 * <b>After: Factory 패턴을 사용한 코드</b>
 * <p>
 *    해당 케이크 클래스를 삭제하고 CakeFactory 클래스에서 해당 케이크를 생성하는 메서드를 삭제하면 됩니다.
 *    이렇게 하면 주문하는 곳인 CakeStore 클래스는 수정하지 않아도 됩니다.
 *    케이크 생성 로직은 CakeFactory 클래스에 의존하므로, 케이크를 삭제하더라도 CakeStore 코드는 영향을 받지 않습니다.
 * </p>
 *
 * <br><br>
 *
 * <h3>Factory 패턴의 장점</h3>
 * <p>
 *    Factory 패턴을 사용한 코드에서의 장점은 다음과 같습니다:
 * </p>
 * <ul>
 *    <li><strong>확장성:</strong> 새로운 이벤트를 추가하거나 기존 이벤트를 삭제할 때 기존 코드를 수정하지 않고도 변경이 가능합니다.</li>
 *    <li><strong>유지보수 용이성:</strong> 각 이벤트 생성 로직이 한 곳에 집중되어 있으므로 유지보수가 용이합니다.</li>
 *    <li><strong>분리된 책임:</strong> 특정 클래스가 이벤트 생성 책임을 갖고 있어 코드가 더 명확하게 분리됩니다.</li>
 * </ul>
 * <p>
 *    Factory 패턴을 사용하지 않은 코드에서는 이벤트 종류마다 조건문이 중복되어 있어 코드의 중복성이 높고 변경이 번거로우며 오류 발생 가능성이 높아집니다.
 *    Factory 패턴을 사용하면 코드를 유연하게 관리할 수 있도록 하여 앞으로의 변경사항에 대비할 수 있습니다.
 * </p>
 *
 *
 */
public class FactoryPatternDocumentation{
}