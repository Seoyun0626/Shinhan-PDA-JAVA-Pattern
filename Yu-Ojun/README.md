
## 목차
#### 1) Strategy 패턴
##### &emsp;&emsp;i) 디자인 패턴 소개
##### &emsp;&emsp;ii) UML 설명
##### &emsp;&emsp;iii) 코드 설명
##### &emsp;&emsp;iv) 디자인 패턴을 사용함에 따른 결과 해석 (before & after)
##### &emsp;&emsp;
#### 2) State 패턴 & Singleton 패턴
##### &emsp;&emsp;i) 디자인 패턴 소개
##### &emsp;&emsp;ii) UML 설명
##### &emsp;&emsp;iii) 코드 설명
##### &emsp;&emsp;iv) 디자인 패턴을 사용함에 따른 결과 해석 (before & after)
##### &emsp;&emsp;
#### 3) Factory 패턴
##### &emsp;&emsp;i) 디자인 패턴 소개
##### &emsp;&emsp;ii) UML 설명
##### &emsp;&emsp;iii) 코드 설명
##### &emsp;&emsp;iv) 디자인 패턴을 사용함에 따른 결과 해석 (before & after)
##### &emsp;&emsp;
#### 4) 소감 및 느낀 점
##### &emsp;&emsp; i) 과제 진행시에 가장 어려웠던 점과 해결 방법
##### &emsp;&emsp; ii) 소감 및 느낀 점

## 1. Strategy 패턴

![strategy](https://github.com/kimdabeans/PDA-JavaPattern/assets/85153500/0bc68d4c-0dc3-43e9-92e7-6a3f96f6703e)

#### 디자인 패턴 소개

금융 서비스에서는 다양한 금융 알고리즘 전략이 필요하고, 실제 투자 중에는 다양하게 투자 전략을 선택해야 합니다. 투자 전략, 계산 방법 및 수익률 예측은 다양하고, 고유한 클래스로 구현되지만, 런타임에 전략을 교체해야 하는 상황이 존재합니다.
**Strategy 패턴은 이런 요구 사항을 충족시키고, 다양한 투자 전략을 런타임에 교체할 수 있게 합니다.**

#### UML 설명

먼저 여러 투자 전략들은 TradingStrategy 인터페이스를 구현하면서 표현됩니다. 투자 전략이라고 하면 과거의 데이터를 통해 거래 행위(매도/매수)를 판단하는 행위기 때문에 (실제로 그렇지 않고 제가 임의로 설정한 의미입니다.) 다음 거래 행위를 판단하는 메서드만 존재하고, 이를 각 전략에 따라 구현합니다.
투자자들은 세부적인 투자 전략의 자료형인 객체가 아닌 TradingStrategy 인터페이스 자료형을 가지는 객체를 가지게 됩니다. 또한 기본 정보인 이름을 가지게 되며, 계좌 내 잔액과 보유한 주식 자산을 필드로 가지고 있습니다. 그리고 각 투자자들만이 할 수 있는 행위들을 메서드로 정의합니다. 예를 들어 매도/매수 등이 있습니다.
요약하자면, 투자 전략은 인터페이스를 통해 구현되고 있으며, 투자자들은 투자 전략 객체만을 가지고 있으면서 Strategy 패턴을 구현한 것을 확인할 수 있습니다.

#### 코드 설명

본 코드는 Strategy 패턴을 사용하여 투자 전략을 구현합니다. 10번에 걸쳐서 주가는 일정폭 안에서 랜덤으로 정해집니다. 적극적인 투자 전략은 과거의 주가와 비교하여 주가가 떨어졌을 때 미래를 생각해서 주식을 매매하고, 주가가 올랐을 때는 미래를 생각해서 주식을 매도합니다. 반대로 소극적인 투자 전략은 과거의 주가보다 주가가 떨어졌을 때 매도하고, 주식이 오르면 매매합니다. (실제 투자 전략과 관련은 없고 임의로 설정한 전략입니다.)
실제 주가와 비슷한 형태라면 당연히 적극적인 투자 전략이 압도적으로 손해를 볼 수 밖에 없습니다. 적극적인 투자 전략은 미리 지정해둔 이익 정도를 얻으면 모두 매매하는 등의 다른 전략과 합쳐져야 어느 정도의 이익을 볼 수 있습니다. 하지만 다른 전략과 합치는 과정은 생각보다 복잡하고, Strategy 패턴을 구현하는 부분에서도 정확한 예시가 될 수 없기 때문에 적극적인 투자 방법은 손해밖에 볼 수 없는 형태로 구성하였습니다. 하지만 예외의 폭을 줄이기 위해서 주식 가격이 일정하게 변화하는 것이 아닌 랜덤으로 변화하게끔 구성하였습니다.

#### 디자인 패턴을 사용함에 따른 결과 해석 (before & after)

이러한 방식이 프로그램을 복잡하게 만드는 것처럼 보이지만 그렇지 않습니다. 만약 적극적인 투자 전략을 개량하고 싶다고 가정을 했을 때, 저는 Strategy 패턴을 사용했기 때문에 인터페이스를 수정하지 않고 적극적인 투자 전략 클래스만 수정하면됩니다. 게다가, 위임을 해서 약한 결합으로 객체끼리 연결되어 있기 때문에 투자 전략을 용이하게 전환할 수 있습니다. 세부 투자 전략에서는 과거의 주가와 현재의 주가를 비교해서 Trade(매도/매수를 enum으로 구성)를 어떻게 할지만 결정하면 됩니다.
만약 Strategy 패턴을 쓰지 않는다면 새로운 투자 전략이 생겼을 때 기존 투자 전략과 공통적인 부분의 코드도 모두 새로 작성해야 합니다. 그리고, 선택한 투자 전략이 손해가 크다고 해도 State 패턴을 사용하지 않았기 때문에 런타임에 전략적으로 전략을 교체할 수 없습니다. 하지만, 복잡한 투자 전략을 케이스별로 구별하지 않고 Strategy 패턴을 이용하여 구현했기 때문에 실제 투자 전략이라면 이익과 손해를 계산하여 런타임에 전략을 교체할 것입니다.

## 2. State 패턴 & Singleton 패턴

![state_singleton](https://github.com/kimdabeans/PDA-JavaPattern/assets/85153500/6af28359-826a-4e87-9617-5d0cfe36b9e9)

#### 디자인 패턴 소개

금융 서비스에서는 다양한 계좌 상태 혹은 거래 상태가 존재합니다.
**State 패턴은 '상태'를 클래스로 표현하고 클래스를 전환함으로써 '상태 변화'를 나타낼 수 있습니다.**

계좌 상황에 따라 계좌 상태가 교체되었다고 해도 상태는 반드시 단일된 객체이자 정보이어야 합니다. 예를 들면 아주 튼튼한 보안을 가지고 있는 상태가 있다고 해보겠습니다. 이 상태를 만약 클래스로 표현한다면 이 객체는 반드시 하나의 인스턴스만 만들어져야 합니다. 왜냐하면, 훌륭한 보안성을 갖춘 상태 정보가 새롭게 하나 더 만들어진다면 굉장히 큰 비용이 드는 업무(훌륭한 보안성을 유지하는 것은 많은 인력과 시간과 장비가 투여될 것입니다)이기 때문에 객체 생성에 굉장히 많은 비용이 들 것입니다. 또한, 상태 정보 그 자체를 가지고 있는 객체이기 때문에 다른 객체가 하나 더 생긴다면 "상태" 자체를 클래스로 표현한 의미가 옅어질 수 있습니다. 마지막으로 보안적으로도 약해질 수 있습니다.

**Singleton 패턴은 이러한 요구 사항을 충족시키며, 하나의 인스턴스만 생성하고 전역적으로 접근할 수 있도록 합니다.**

#### UML 설명

먼저 계좌 내 잔액에 따른 상태는 State 인터페이스를 통해 구현됩니다. 계좌 내 잔액 상태에 따라서 매도/매수를 하는 행위를 제한하고 경고하는 행위를 나타내고 싶기 때문에 인터페이스에서는 매도와 매수를 정의합니다.
그리고, 시간에 따른 주식 장 상태는 Time 인터페이스를 통해 구현됩니다. 각 주식 장이 마감되었거나 개장되었거나 하는 상황을 알림을 통해 투자자들에게 알려야하기 때문에 알림을 보내는 함수를 정의힙니다.
결국 패턴 구조상 State와 Time은 같은 형태인 것을 확인할 수 있습니다. 각 세부 상태들은 singleton을 통해 인스턴스를 한 개로 제한하고, 장 시간 상태와 계좌 내 잔액에 따른 상태는 모두 enum으로 제한하고(State 인터페이스는 StateType, Time 인터페이스는 TimeType) State 패턴을 사용합니다. 즉, 불을 끼고 키는 것처럼 본 서비스는 상태 자체를 클래스화 했기 때문에 상황에 따라 상태를 딸깍딸깍 바꿀 수 있는 것입니다.
SafeFrame 클래스는 시간별로 바뀌는 주가와 계좌 잔액에 따른 상태, 시간 상태를 필드로 가지고 있습니다. 이 클래스 또한 Context 인터페이스를 구현합니다.
요약하자면, 각 상태들은 인터페이스를 통해 정의되고 있으며, Enum을 통해 상태들을 제한하고 각 상태 객체를 한개씩으로 제한하면서 State 패턴과 Singleton 패턴을 구현하고 있습니다. 또한, 서비스의 메인 로직과 GUI를 담당하는 SafeFrame 클래스는 Context 인터페이스를 구현하면서 실행되고 있는 것을 확인할 수 있습니다.

#### 코드 설명

본 코드는 State 패턴, Singleton 패턴, Map 자료 구조를 사용하고 고객 계좌의 잔액에 따라 상태를 구분합니다. 그리고, JAVA GUI를 통해 고객 계좌 상태에 따라 매도, 매매를 추천하고 경고합니다. 주식 거래 장 상태는 주식 거래가 허용되는 시간을 고려하여 또 다시 State 패턴과 Singleton 패턴, Map을 이용하여 구분합니다. 거래가 불가능한 시간에는 주가가 바뀌지 않고 어떠한 거래도 허용하지 않습니다. 거래 허용 시간에 주가는 1초에 한번씩 바뀌며, -1000, -500, 0, 500, 1000 중에 하나의 랜덤한 값으로 기존 주가에 더해지면서 바뀌게 됩니다. 이렇게 변화하는 주가에 따라 계좌 잔액이 바뀌게 되고, 고객 신용 등급 상태는 바뀐 계좌 잔액에 따라 상태가 바뀌게 됩니다.
마지막으로 Map 자료 구조를 초기화하는 함수와 모든 클래스에서 공통적으로 사용해야 하는 고객 계좌의 잔액은 static으로 선언해야 하기 때문에 환경 설정의 의미를 담고 있는 Utility 클래스를 만듭니다. Utility 클래스 내의 static 함수를 통해 주식 장 개장 시간과 마감 시간 또한 유연하게 Main 클래스에서 설정할 수 있습니다.

#### 디자인 패턴을 사용함에 따른 결과 해석 (before & after)

이러한 방식은 상태에 의존해서 서비스의 처리를 수행하고 있습니다. 이는 서비스를 개발하면서 반드시 나타날 수 밖에 없는 케이스 처리를 객체 지향적으로 처리한다는 것에 의미가 있다고 생각합니다.
if, else 문과 같은 조건문을 사용하게 된다면 각 케이스에 변화가 생기거나, 추가해야 할 경우가 생긴다면 굉장히 복잡하게 될 것입니다. 하지만 상태 자체가 클래스로 표현되고, 각 상태는 singleton 패턴을 사용해서 하나의 인스턴스만 가지게 되기 때문에 복잡한 케이스를 안정적으로 처리할 수 있게 합니다.
저는 단순하게 적은 양의 케이스의 시간과 계좌 상태에만 적용을 하게 되었지만, 각 시간별로 케이스를 다르게 하고 싶거나 복잡하고 다양한 계좌 상태에 행동을 부여하고 싶다면 굉장히 효과적인 디자인 패턴이라고 생각합니다. 만약 Singleton 패턴과 State 패턴을 사용하지 않았다면 복잡한 계좌 상태 혹은 금융 상품 상태 등을 조건문을 활용하여 구분할 수 밖에 없고 이는 코드 유지, 보수에 굉장히 큰 비용을 소모하게 될 것입니다.
하지만, State 패턴을 사용했기 때문에 서비스는 어떤 상태인지는 모르고 단지 상태에만 의존하게 되고, 조건에 따라 상태만 교체해줌으로써 코드 유지, 보수에 큰 도움이 될 것 입니다.

## 3. Factory 패턴

![factory](https://github.com/kimdabeans/PDA-JavaPattern/assets/85153500/0b025034-a6ac-48dc-ad2f-6f1b01a62b1d)

#### 디자인 패턴 소개

금융 서비스에서는 여러 종류의 금융 상품을 생성해야 할 때가 있습니다.
**Factory Method 패턴은 객체 생성을 서브 클래스에 위임하여 쉽게 확장 가능한 디자인을 제공합니다.**

#### UML 설명

먼저 framework 패키지에서 인스턴스 생성 방법을 정의합니다. Factory 클래스를 통해 Product 객체를 생성하는 방법을 정의하고, Product 객체를 생성할 수 있게 합니다.
SecuritiesFactory 클래스는 Factory 클래스를 상속 받아 Securities 객체를 생성할 수 있게 합니다.
Securities 클래스는 Product 클래스를 상속 받아 파생결합증권의 로직을 구현합니다.


#### 코드 설명

본 코드는 Factory 패턴을 사용하여 사용자별로 계좌를 만들고 ELS, ELW, DLS 와 같은 파생결합증권을 등록한 후에 사용하는 과정을 설명하고 있습니다.

#### 디자인 패턴을 사용함에 따른 결과 해석 (before & after)

이러한 방식의 핵심은 상위 클래스에서 처리의 뼈대를 만들고, 하위 클래스에서 구체적인 살을 붙인다는 것입니다. 인스턴스 생성 방법은 모두 상위 클래스에서 결정하지만, 구체적인 부분(심지어 이름까지도) 하위 클래스가 붙입니다.
이러한 패턴이 얻어낼 수 있는 효과는 인스턴스 생성을 위한 프레임워크와 실제 인스턴스를 생성하는 클래스를 나누어 생각할 수 있다는 것입니다.
예를 들어 같은 프레임워크를 사용하여 전혀 다른 증권 상품을 만든다고 생각해보면, framework 패키지를 import 하는 별개의 상품 패키지를 만들게 될 것 입니다.  
만약 Factory 패턴을 사용하지 않았다면, framework  패키지를 수정해야 할 것입니다. 하지만, Factory 패턴을 적절히 사용했기 때문에 framework 패키지 안에는 파생결합증권 패키지를 import 하지 않았고, Product 와 Factory 클래스에는 파생결합증권과 같은 구체적인 클래스 이름이 전혀 없습니다. 즉, 이는 framework 패키지는 제가 개발했던 파생결합증권 패키지에 의존하지 않고 있고, 새로운 상품을 만들 때 framework 패키지를 전혀 수정하지 않아도 된다는 결론이 도출됩니다.

## 4. 소감 및 느낀 점
#### 과제 진행시에 가장 어려웠던 점과 해결 방법

과제를 진행할 때 최대한 효율적으로 진행하고 싶다는 생각으로 책에 있는 코드를 모두 쳐보고, 이 코드들을 바탕으로 저의 아이디어에 맞게 바꾼 후 UML을 그리자 라는 생각으로 진행했었습니다. 하지만, 디자인 패턴을 제대로 이해하지 않고 기존 코드를 저의 시나리오대로 끼워 맞추는 방식은 비효율적일뿐만 아니라 올바르게 기능이 작동하도록 코드를 완성할 수 없는 방식이었습니다. 이렇게 '기존 코드를 내 시나리오대로 바꾼다' 라는 방식을 버리는 게 이번 과제 진행에서 가장 힘들었습니다. 투입한 시간이 많았고, 조금만 더 하면 할 수 있을 것 같은 느낌이었기 때문입니다. 하지만 이 방식대로라면 코드를 완성해도 제가 짠 코드를 이해하지 못할 것 같았습니다. 그래서 저는 무턱대고 책을 다시 읽으며 디자인 패턴을 이해하고자 하는게 아니라 객체 지향 디자인을 하는 이유부터 생각해보았습니다. 결국 객체 지향 디자인 패턴을 사용하는 이유는 현실 세계를 서비스로 구현하는 과정에서 코드의 재사용성을 높이는 것이라고 파악했고, 이런 근본적인 이해를 바탕으로 왜 이런 디자인 패턴을 사용하는지를 고민해보니 코드 작성이 아닌 UML 작성을 먼저 시작할 수 밖에 없었습니다. 결국 아이러니하게도 기술적인 측면보다 잘못 생각한 방식을 버리고 새로운 방식으로 접근하는 것이 가장 어려웠지만, 왜 이런 기술을 사용하는지 궁금증을 가지고 새로운 관점으로 접근하면서 어려웠던 점을 해결할 수 있었습니다.

#### 소감 및 느낀 점
디자인 패턴을 글로만 읽고, 예시만 따라하는 것은 디자인 패턴을 절대 이해했다고 할 수 없는 것 같습니다. 실제 이 패턴을 어떤 상황에서 접목시킬 수 있을까?를 지속적으로 고민하는 것이 가장 중요하다고 생각합니다. 결국 디자인 패턴은 정답이 아니라 효율적으로 코드를 작성하기 위한 방법 중 하나입니다. 제가 이 과제를 진행하면서 저는 이런 패턴으로 구현했지만 다른 분들은 같은 기능이라도 다른 패턴으로 구현했을 것입니다. 결론은 왜 이런 디자인 패턴을 사용하는 것인지, 그렇다면 나는 어떤 상황에서 이런 패턴을 사용할 것 같은지를 계속 고민하고 공부해야 하는 것 같습니다. 어찌 보면 이런 디자인 패턴 공부가 별 일이 아닐 수 있지만, 설계도를 만드는 사람과 설계도를 보고 기계를 만드는 사람의 중요도가 다르듯이 설계도를 잘 만드는 사람으로 성장하기 위해 많은 공부뿐만 아니라 고민도 해야하는 것을 느꼈습니다.
